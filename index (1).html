<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>From - Maze Game</title>
    <style>
*{
    margin:0;
    padding:0;
}
html, body {
    background-color: white;
    color: white;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 0;
    background-image: url(halo.webp);
    background-size: cover;
    background-attachment: fixed;
}

#game-container {
    position: relative;
    width: 484px;
    height: 484px;
    background-color: #0f0f0f;
}

#player1, #player2 {
    position: absolute;
    width: 10px;
    height: 10px;
    border-radius: 50%;
}

#player1 {
    background-color: red;
}

#player2 {
    background-color: blue;
}

svg {
    position: absolute;
    top: 0;
    left: 0;
}
    </style>
</head>
<body>
    <h1>From - The Maze</h1>
    <p>Navigate the maze, but beware, the monsters are watching...</p>
    <div id="game-container">
        <svg id="maze" width="484" height="484" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <title>30 by 30 orthogonal maze</title>
            <desc>30 by 30 orthogonal maze generated by The Maze Generator Website (https://www.mazegenerator.net/).</desc>
            <g fill="none" stroke="grey" stroke-width="2" stroke-linecap="square">
              <line x1="2" y1="2" x2="226" y2="2" />
              <line x1="242" y1="2" x2="482" y2="2" />
              <line x1="34" y1="18" x2="50" y2="18" />
              <line x1="82" y1="18" x2="98" y2="18" />
              .
              .
              .
              <line x1="466" y1="386" x2="466" y2="418" />
              <line x1="466" y1="434" x2="466" y2="450" />
              <line x1="482" y1="2" x2="482" y2="482" />
              <circle id="player1" cx="58" cy="50" r="5" fill="red"></circle>
              <circle id="player2" cx="90" cy="90" r="5" fill="blue"></circle>
            </g>
            <polyline fill="none" stroke="#ff0000" stroke-width="2" stroke-linecap="square" stroke-linejoin="round" points="234,2 234,10 250,10 250,26 266,26 266,42 218,42 218,58 250,58 250,74 266,74 266,106 282,106 282,90 298,90 298,106 314,106 314,90 346,90 346,74 378,74 378,90 362,90 362,106 330,106 330,138 346,138 346,170 362,170 362,202 378,202 378,186 394,186 394,218 362,218 362,250 266,250 266,234 234,234 234,202 218,202 218,218 202,218 202,186 186,186 186,170 170,170 170,202 154,202 154,218 138,218 138,234 154,234 154,250 170,250 170,266 154,266 154,282 138,282 138,298 154,298 154,314 170,314 170,282 186,282 186,266 218,266 218,282 202,282 202,298 298,298 298,314 282,314 282,330 314,330 314,314 346,314 346,330 362,330 362,346 346,346 346,362 378,362 378,394 362,394 362,378 330,378 330,346 298,346 298,394 282,394 282,410 266,410 266,458 250,458 250,482" />
          </svg>       
      </div>
      <script src="sat.js"></script>
      <script>
const mazeLines = document.querySelectorAll('svg line');
const player1Elem = document.getElementById('player1');
const player2Elem = document.getElementById('player2');

let player1 = new SAT.Circle(new SAT.Vector(240, 10), 5);
let player2 = new SAT.Circle(new SAT.Vector(225, 10), 5);

const speed = 2;
const maxDistance = 100;

const keys = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false,
    w: false,
    a: false,
    s: false,
    d: false,
};

document.addEventListener('keydown', (e) => {
    keys[e.key] = true;
});

document.addEventListener('keyup', (e) => {
    keys[e.key] = false;
});

function detectCollision(circle) {
    for (let line of mazeLines) {
        const x1 = parseFloat(line.getAttribute('x1'));
        const y1 = parseFloat(line.getAttribute('y1'));
        const x2 = parseFloat(line.getAttribute('x2'));
        const y2 = parseFloat(line.getAttribute('y2'));

        const wallPolygon = new SAT.Polygon(new SAT.Vector(), [
            new SAT.Vector(x1, y1),
            new SAT.Vector(x2, y2),
        ]);

        if (SAT.testCirclePolygon(circle, wallPolygon)) {
            return true;
        }
    }
    return false;
}

function handleMovement(circle, stationaryCircle, keys = {}) {
    const originalPos = new SAT.Vector(circle.pos.x, circle.pos.y);

    const newPos = new SAT.Vector(circle.pos.x, circle.pos.y);

    // Move vertically
    if (keys.w) newPos.y -= speed;
    if (keys.s) newPos.y += speed;
    const tempCircleY = new SAT.Circle(new SAT.Vector(newPos.x, newPos.y), circle.r);
    if (!detectCollision(tempCircleY)) {
        circle.pos.y = newPos.y;
    }

    // Move horizontally
    if (keys.a) newPos.x -= speed;
    if (keys.d) newPos.x += speed;
    const tempCircleX = new SAT.Circle(new SAT.Vector(newPos.x, circle.pos.y), circle.r);
    if (!detectCollision(tempCircleX)) {
        circle.pos.x = newPos.x;
    }

    // Restrict position if too far from other circle
    restrictPosition(circle, stationaryCircle, originalPos);
}



function restrictPosition(movingCircle, stationaryCircle, originalPos) {
    const dx = movingCircle.pos.x - stationaryCircle.pos.x;
    const dy = movingCircle.pos.y - stationaryCircle.pos.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance > maxDistance) {
        const angle = Math.atan2(dy, dx);
        const restrictedX = stationaryCircle.pos.x + Math.cos(angle) * maxDistance;
        const restrictedY = stationaryCircle.pos.y + Math.sin(angle) * maxDistance;

        // Check if the restricted position collides with walls
        const restrictedCircle = new SAT.Circle(new SAT.Vector(restrictedX, restrictedY), movingCircle.r);
        if (!detectCollision(restrictedCircle)) {
            movingCircle.pos.x = restrictedX;
            movingCircle.pos.y = restrictedY;
        } else {
            // Reset to the original position if restricted position is invalid
            movingCircle.pos.x = originalPos.x;
            movingCircle.pos.y = originalPos.y;
        }
    }
}

const endZone = new SAT.Box(new SAT.Vector(0, 482), 500, 500).toPolygon(); // Adjust position and size as needed

function isInEndZone(circle) {
    return SAT.testCirclePolygon(circle, endZone);
}

function checkEndCondition() {
    if (isInEndZone(player1) && isInEndZone(player2)) {
        triggerEndSequence();
    }
}

function triggerEndSequence() {
    alert("Congratulations! Both players reached the end of the maze!");
}

function update() {
    handleMovement(player1, player2, {
        w: keys.w,
        s: keys.s,
        a: keys.a,
        d: keys.d,
    });
    handleMovement(player2, player1, {
        w: keys.ArrowUp,
        s: keys.ArrowDown,
        a: keys.ArrowLeft,
        d: keys.ArrowRight,
    });

    player1Elem.setAttribute('cx', player1.pos.x);
    player1Elem.setAttribute('cy', player1.pos.y);
    player2Elem.setAttribute('cx', player2.pos.x);
    player2Elem.setAttribute('cy', player2.pos.y);

    requestAnimationFrame(update);
    checkEndCondition();
}

update();
    </script>
    
  </body>
  </html>